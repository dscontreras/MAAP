classdef Queue < handle
    %QUEUE Summary of this class goes here
    %   Detailed explanation goes here
    
    properties (SetAccess = 'private')
        %An index of which operations in the Queue need to be checked for
        %whether they should be deleted
        condition_evals;
        %Map of which operations in the queue transfer data to which other
        %functions
        data_transfer_map;
        %number of operations in the queue
        length;
        %the actual contents of the queue
        list;
        %flag indicating whether the queue has anything to do
        done;
    end
    
    methods
        %operation_list and data_transfer_map should be a cell arrays
        function obj = Queue(operation_list)
            obj.length = 0;
            obj.done = false;
            if(nargin > 0)
                for i = 1:length(operation_list)
                    obj.add_to_queue(operation_list{i});
                end
            else
                obj.condition_evals = {};
                obj.data_transfer_map = {};
            end
        end
        
        function add_to_queue(obj, operation)
            obj.length = obj.length + 1;
            %If the object should be inserted at the start of the list
            if(strcmp(operation.insertion_type, 'start'))
                for i = obj.length:1
                    obj.list{i + 1} = obj.list{i};
                end
                obj.list{1} = operation;
                obj.add_to_map(operation, 1);
            %Otherwise, insert it at the end
            else
                obj.list{obj.length} = operation;
                obj.extend_map(operation);
            end
        end
        
        function add_to_map(obj, operation, address_inserted)
            obj.data_transfer_map{address_inserted} = {operation.name, operation.outputs};
        end
        
        function extend_map(obj, operation)
            obj.data_transfer_map{length(obj.data_transfer_map) + 1} = {operation.name, operation.outputs};
        end
        
        function execute(obj)
            for i = 1:obj.length
                if(obj.list{i}.get_num_args_in() <= 0)
                    obj.list{i}.execute();
                else
                    obj.list{i}.execute(obj.list{i}.inputs);
                end
                stopped = obj.list{i}.check_stop();
                if(stopped)
                    obj.list = [obj.list{1:(i - 1)} obj.list{(i + 1):end}];
                    obj.length = length(obj.list);
                    if(obj.length == 0)
                        obj.done = true;
                    end
                end
            end
        end
        
%         function transfer_data(obj, sender, data_sent)
%             %iterate through each dependent of the sender
%             for i = 1:length(get(sender, 'dependents'))
%                 %operation_receiving is the operation is the one we are sending to
%                 operation_receiving = obj.list{i};
%                 %Now iterate through the data_transfer_map's list of data
%                 %to be sent
%                 for j = 1:length(obj.data_transfer_map{i}{2})
%                     index_of_variable_needed_in_transfer_map = obj.data_transfer_map{i}{2}{j};
%                     data_variable_needed = data_sent{index_of_variable_needed_in_transfer_map};
%                     operation_receiving.set_in_buffer(index_of_variable_needed_in_transfer_map, data_variable_needed);
%                 end
%             end
%         end
        
        function bool = finished(obj)
            bool = obj.done;
        end
        
        function delete(obj)
            for i = 1:obj.length
                delete(obj.list{i});
            end
            obj.length = 0;
            delete(obj);
        end
        
        function l = fetch_list(obj)
            l = obj.list;
        end
    end
    
end

